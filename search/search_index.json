{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"staff","text":"<p>Staff is a toolbox for computer assisted composition in Python.</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>pip install inegm.staff\n</code></pre>"},{"location":"api/duration/","title":"duration","text":""},{"location":"api/duration/#tempo","title":"Tempo","text":"<p>A musical tempo.</p> <p>Parameters:</p> Name Type Description Default <code>bpm</code> <code>int</code> <p>Beats per minute</p> required <code>beat</code> <code>Duration</code> <p>Reference beat duration</p> <code>Duration(4)</code> Source code in <code>staff/duration.py</code> <pre><code>@dataclass(frozen=True)\nclass Tempo:\n    \"\"\"A musical tempo.\n\n    Args:\n        bpm: Beats per minute\n        beat: Reference beat duration\n    \"\"\"\n\n    bpm: int\n    beat: Duration = Duration(4)\n\n    def __post_init__(self):\n        if not isinstance(self.bpm, int):\n            raise TypeError(\"bpm must be expressed as an 'int'\")\n\n        if self.bpm &lt; MIN_TEMPO_BPM:\n            raise ValueError(f\"bpm must be at least {MIN_TEMPO_BPM}\")\n\n        if self.bpm &gt; MAX_TEMPO_BPM:\n            raise ValueError(f\"bpm must be at most {MAX_TEMPO_BPM}\")\n\n        if not isinstance(self.beat, Duration):\n            raise TypeError(\"beat must be an instance of 'Duration'\")\n\n    @property\n    def beat_milliseconds(self) -&gt; float:\n        \"\"\"Get the length of each beat in milliseconds.\n\n        Returns:\n            Reference beat duration in milliseconds\n        \"\"\"\n        return 60 / self.bpm * 1000\n</code></pre>"},{"location":"api/duration/#staff.duration.Tempo.beat_milliseconds","title":"<code>beat_milliseconds: float</code>  <code>property</code>","text":"<p>Get the length of each beat in milliseconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>Reference beat duration in milliseconds</p>"},{"location":"api/duration/#duration","title":"Duration","text":"<p>Musical duration.</p> <p>Parameters:</p> Name Type Description Default <code>denominator</code> <code>int</code> <p>The 4 in 1/4 for example</p> required <code>dots</code> <code>int</code> <p>The modifying dots</p> <code>0</code> <code>is_rest</code> <code>bool</code> <p>Is or isn't a silent duration</p> <code>False</code> <p>Implements <code>total_ordering</code> against <code>Duration</code>.</p> <p>Implements the following operations:</p> <pre><code>- `__add__` against `Duration`\n- `__radd__` against `Duration`\n- `__sub__` against `Duration`\n- `__mul__` against `int` and `float`\n- `__rmul__` against `int` and `float`\n- `__truediv__` against `int` and `float`\n</code></pre> <p>Implements total ordering.</p> <p>Examples:</p> <p>Given a <code>Tempo</code>, a <code>Duration</code> length in milliseconds is:</p> <pre><code>&gt;&gt;&gt; Duration(8, dots=1).milliseconds(Tempo(120))\n375.0\n</code></pre> <pre><code>&gt;&gt;&gt; Duration(8, dots=1).milliseconds(Tempo(60))\n750.0\n</code></pre> <p><code>Duration</code> arithmetic is simple:</p> <pre><code>&gt;&gt;&gt; Duration(4) + Duration(8)\nDuration(denominator=4, dots=1, is_rest=False)\n</code></pre> <pre><code>&gt;&gt;&gt; sum((Duration(4), Duration(8), Duration(8)))\nDuration(denominator=2, dots=0, is_rest=False)\n</code></pre> <pre><code>&gt;&gt;&gt; Duration(4) - Duration(8)\nDuration(denominator=8, dots=0, is_rest=False)\n</code></pre> <pre><code>&gt;&gt;&gt; Duration(4) * 2\nDuration(denominator=2, dots=0, is_rest=False)\n</code></pre> <pre><code>&gt;&gt;&gt; Duration(2) / 2\nDuration(denominator=4, dots=0, is_rest=False)\n</code></pre> <p>Notice that adding or substracting two rests returns a rest:</p> <pre><code>&gt;&gt;&gt; Duration(4, is_rest=True) + Duration(8, is_rest=True)\nDuration(denominator=4, dots=1, is_rest=True)\n</code></pre> <pre><code>&gt;&gt;&gt; Duration(4, is_rest=True) - Duration(8, is_rest=True)\nDuration(denominator=8, dots=0, is_rest=True)\n</code></pre> <p>but that if one of the two <code>Duration</code> instances is not a rest:</p> <pre><code>&gt;&gt;&gt; Duration(4, is_rest=True) + Duration(8, is_rest=False)\nDuration(denominator=4, dots=1, is_rest=False)\n</code></pre> <pre><code>&gt;&gt;&gt; Duration(4, is_rest=True) - Duration(8, is_rest=False)\nDuration(denominator=8, dots=0, is_rest=False)\n</code></pre> <p>The same goes for the other operations:</p> <pre><code>&gt;&gt;&gt; Duration(4, is_rest=True) * 2\nDuration(denominator=2, dots=0, is_rest=True)\n</code></pre> <pre><code>&gt;&gt;&gt; Duration(2, is_rest=True) / 2\nDuration(denominator=4, dots=0, is_rest=True)\n</code></pre> <p><code>Duration</code> instances are comparable:</p> <pre><code>&gt;&gt;&gt; Duration(2) &gt; Duration(4)\nTrue\n</code></pre> Source code in <code>staff/duration.py</code> <pre><code>@total_ordering\n@dataclass(frozen=True)\nclass Duration:\n    \"\"\"Musical duration.\n\n    Args:\n        denominator: The 4 in 1/4 for example\n        dots: The modifying dots\n        is_rest: Is or isn't a silent duration\n\n    Implements `total_ordering` against `Duration`.\n\n    Implements the following operations:\n\n        - `__add__` against `Duration`\n        - `__radd__` against `Duration`\n        - `__sub__` against `Duration`\n        - `__mul__` against `int` and `float`\n        - `__rmul__` against `int` and `float`\n        - `__truediv__` against `int` and `float`\n\n    Implements total ordering.\n\n    Examples:\n        Given a `Tempo`, a `Duration` length in milliseconds is:\n\n        &gt;&gt;&gt; Duration(8, dots=1).milliseconds(Tempo(120))\n        375.0\n\n        &gt;&gt;&gt; Duration(8, dots=1).milliseconds(Tempo(60))\n        750.0\n\n        `Duration` arithmetic is simple:\n\n        &gt;&gt;&gt; Duration(4) + Duration(8)\n        Duration(denominator=4, dots=1, is_rest=False)\n\n        &gt;&gt;&gt; sum((Duration(4), Duration(8), Duration(8)))\n        Duration(denominator=2, dots=0, is_rest=False)\n\n        &gt;&gt;&gt; Duration(4) - Duration(8)\n        Duration(denominator=8, dots=0, is_rest=False)\n\n        &gt;&gt;&gt; Duration(4) * 2\n        Duration(denominator=2, dots=0, is_rest=False)\n\n        &gt;&gt;&gt; Duration(2) / 2\n        Duration(denominator=4, dots=0, is_rest=False)\n\n        Notice that adding or substracting two rests returns a rest:\n\n        &gt;&gt;&gt; Duration(4, is_rest=True) + Duration(8, is_rest=True)\n        Duration(denominator=4, dots=1, is_rest=True)\n\n        &gt;&gt;&gt; Duration(4, is_rest=True) - Duration(8, is_rest=True)\n        Duration(denominator=8, dots=0, is_rest=True)\n\n        but that if one of the two `Duration` instances is not a rest:\n\n        &gt;&gt;&gt; Duration(4, is_rest=True) + Duration(8, is_rest=False)\n        Duration(denominator=4, dots=1, is_rest=False)\n\n        &gt;&gt;&gt; Duration(4, is_rest=True) - Duration(8, is_rest=False)\n        Duration(denominator=8, dots=0, is_rest=False)\n\n        The same goes for the other operations:\n\n        &gt;&gt;&gt; Duration(4, is_rest=True) * 2\n        Duration(denominator=2, dots=0, is_rest=True)\n\n        &gt;&gt;&gt; Duration(2, is_rest=True) / 2\n        Duration(denominator=4, dots=0, is_rest=True)\n\n        `Duration` instances are comparable:\n\n        &gt;&gt;&gt; Duration(2) &gt; Duration(4)\n        True\n    \"\"\"\n\n    denominator: int\n    dots: int = 0\n    is_rest: bool = False\n\n    def __post_init__(self):\n        if not isinstance(self.denominator, int):\n            raise TypeError(\"denominator must be expressed as an 'int'\")\n\n        if self.denominator &gt; MAX_DURATION_DENOMINATOR:\n            raise ValueError(f\"max denominator is {MAX_DURATION_DENOMINATOR}\")\n\n        if self.denominator &lt;= 0:\n            raise ValueError(\"denominator must be greater than 0\")\n\n        if not isinstance(self.dots, int):\n            raise TypeError(\"dots must be expressed as an 'int'\")\n\n        if self.dots &gt; MAX_DURATION_DOTS:\n            raise ValueError(f\"max dots is {MAX_DURATION_DOTS}\")\n\n        if not is_power_of_two(self.denominator):\n            raise ValueError(\"denominator must be a power of two\")\n\n    @property\n    def decimal(self) -&gt; float:\n        \"\"\"Get the duration as a decimal value.\n\n        Returns:\n            The duration as a decimal\n        \"\"\"\n        dec = 1 / self.denominator\n        for _dot in range(self.dots):\n            dec *= 1.5\n        return dec\n\n    @property\n    def fraction(self) -&gt; Fraction:\n        \"\"\"Get the duration as a Fraction.\n\n        Returns:\n            The duration as a fraction\n        \"\"\"\n        return Fraction(self.decimal)\n\n    def milliseconds(self, tempo: Tempo) -&gt; float:\n        \"\"\"Get the duration in milliseconds, given a tempo.\n\n        Args:\n            tempo: The tempo used to calculate the duration.\n\n        Returns:\n            The duration in milliseconds\n        \"\"\"\n        if not isinstance(tempo, Tempo):\n            raise TypeError(\"tempo must be an instance of 'Tempo'\")\n        return (self.decimal / tempo.beat.decimal) * tempo.beat_milliseconds\n\n    def __gt__(self, other: Duration) -&gt; bool:\n        if not isinstance(other, Duration):\n            raise TypeError(f\"cannot compare Duration with type '{type(other)}'\")\n        return self.decimal &gt; other.decimal\n\n    def __add__(self, other: Duration) -&gt; Duration:\n        if not isinstance(other, Duration):\n            raise TypeError(\n                f\"unsupported operand type(s) for +: 'Duration' and '{type(other)}'\"\n            )\n        try:\n            frac = self.fraction + other.fraction\n            dots = 0\n            while frac.numerator != 1:\n                frac = Fraction(frac / 1.5)\n                dots += 1\n                if dots &gt;= MAX_DURATION_DOTS:\n                    raise ValueError\n            return Duration(\n                frac.denominator,\n                dots=dots,\n                is_rest=self.is_rest and other.is_rest,\n            )\n        except ValueError as err:\n            frac = self.fraction + other.fraction\n            msg = \"the + operation would result in the invalid Duration: \"\n            msg += f\"{frac.numerator}/{frac.denominator}\"\n            raise ValueError(msg) from err\n\n    def __radd__(self, other: Union[int, Duration]) -&gt; Duration:\n        if other == 0:\n            return self\n        if not isinstance(other, Duration):\n            raise TypeError(\n                f\"unsupported operand type(s) for +: 'Duration' and '{type(other)}'\"\n            )\n        return self.__add__(other)\n\n    def __sub__(self, other: Duration) -&gt; Duration:\n        if not isinstance(other, Duration):\n            raise TypeError(\n                f\"unsupported operand type(s) for -: 'Duration' and '{type(other)}'\"\n            )\n        try:\n            frac = self.fraction - other.fraction\n            return Duration(\n                frac.denominator,\n                is_rest=self.is_rest and other.is_rest,\n            )\n        except ValueError as err:\n            msg = \"the - operation would result in an invalid Duration.\"\n            raise ValueError(msg) from err\n\n    def _operate(\n        self,\n        other: Union[int, float],\n        oper: Callable,\n    ) -&gt; Duration:\n        frac = Fraction(oper(self.fraction, other))\n        return Duration(frac.denominator, is_rest=self.is_rest)\n\n    def __mul__(self, other: Union[int, float]) -&gt; Duration:\n        return self._operate(other, operator.mul)\n\n    def __rmul__(self, other: Union[int, float]) -&gt; Duration:\n        return self._operate(other, operator.mul)\n\n    def __truediv__(self, other: Union[int, float]) -&gt; Duration:\n        return self._operate(other, operator.truediv)\n</code></pre>"},{"location":"api/duration/#staff.duration.Duration.decimal","title":"<code>decimal: float</code>  <code>property</code>","text":"<p>Get the duration as a decimal value.</p> <p>Returns:</p> Type Description <code>float</code> <p>The duration as a decimal</p>"},{"location":"api/duration/#staff.duration.Duration.fraction","title":"<code>fraction: Fraction</code>  <code>property</code>","text":"<p>Get the duration as a Fraction.</p> <p>Returns:</p> Type Description <code>Fraction</code> <p>The duration as a fraction</p>"},{"location":"api/duration/#staff.duration.Duration.milliseconds","title":"<code>milliseconds(tempo)</code>","text":"<p>Get the duration in milliseconds, given a tempo.</p> <p>Parameters:</p> Name Type Description Default <code>tempo</code> <code>Tempo</code> <p>The tempo used to calculate the duration.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The duration in milliseconds</p> Source code in <code>staff/duration.py</code> <pre><code>def milliseconds(self, tempo: Tempo) -&gt; float:\n    \"\"\"Get the duration in milliseconds, given a tempo.\n\n    Args:\n        tempo: The tempo used to calculate the duration.\n\n    Returns:\n        The duration in milliseconds\n    \"\"\"\n    if not isinstance(tempo, Tempo):\n        raise TypeError(\"tempo must be an instance of 'Tempo'\")\n    return (self.decimal / tempo.beat.decimal) * tempo.beat_milliseconds\n</code></pre>"},{"location":"api/duration/#tuplet","title":"Tuplet","text":"<p>A duration tuplet (triplet, quintuplet, etc)</p> <p>Parameters:</p> Name Type Description Default <code>divisions</code> <code>int</code> <p>Number of divisions of the total duration</p> required <code>duration</code> <code>Duration</code> <p>The tuplet's total duration</p> required Source code in <code>staff/duration.py</code> <pre><code>@dataclass(frozen=True)\nclass Tuplet:\n    \"\"\"A duration tuplet (triplet, quintuplet, etc)\n\n    Args:\n        divisions: Number of divisions of the total duration\n        duration: The tuplet's total duration\n    \"\"\"\n\n    divisions: int\n    duration: Duration\n\n    def __post_init__(self):\n        if not isinstance(self.divisions, int):\n            raise TypeError(\"divisions must be expressed as an 'int'\")\n\n        if not isinstance(self.duration, Duration):\n            raise TypeError(\"duration must be an instance of 'Duration'\")\n\n    def to_milliseconds(self, tempo: Tempo):\n        \"\"\"The millisecond duration of each subdivision of the tuplet.\n\n        Args:\n            tempo: The tempo used to calculate the duration.\n        \"\"\"\n        if not isinstance(tempo, Tempo):\n            raise TypeError(\"tempo must be an instance of 'Tempo'\")\n        return [\n            self.duration.milliseconds(tempo=tempo) / self.divisions\n            for _ in range(self.divisions)\n        ]\n</code></pre>"},{"location":"api/duration/#staff.duration.Tuplet.to_milliseconds","title":"<code>to_milliseconds(tempo)</code>","text":"<p>The millisecond duration of each subdivision of the tuplet.</p> <p>Parameters:</p> Name Type Description Default <code>tempo</code> <code>Tempo</code> <p>The tempo used to calculate the duration.</p> required Source code in <code>staff/duration.py</code> <pre><code>def to_milliseconds(self, tempo: Tempo):\n    \"\"\"The millisecond duration of each subdivision of the tuplet.\n\n    Args:\n        tempo: The tempo used to calculate the duration.\n    \"\"\"\n    if not isinstance(tempo, Tempo):\n        raise TypeError(\"tempo must be an instance of 'Tempo'\")\n    return [\n        self.duration.milliseconds(tempo=tempo) / self.divisions\n        for _ in range(self.divisions)\n    ]\n</code></pre>"},{"location":"api/numerical/","title":"numerical","text":""},{"location":"api/numerical/#staff.numerical.is_power_of_two","title":"<code>is_power_of_two(number)</code>","text":"<p>Check if a number is a power of two.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The candidate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether or not it is a power of two</p> Source code in <code>staff/numerical.py</code> <pre><code>def is_power_of_two(number: int) -&gt; bool:\n    \"\"\"Check if a number is a power of two.\n\n    Args:\n        number: The candidate\n\n    Returns:\n        Whether or not it is a power of two\n    \"\"\"\n    if not isinstance(number, int):\n        return False\n    return (number &amp; (number - 1) == 0) and number != 0\n</code></pre>"},{"location":"api/pitch/","title":"pitch","text":""},{"location":"api/pitch/#diapason","title":"Diapason","text":"<p>Tuning reference.</p> <p>Parameters:</p> Name Type Description Default <code>reference_midi_number</code> <code>int</code> <p>The reference pitch MIDI number</p> <code>69</code> <code>reference_hertz</code> <code>float</code> <p>The frequency of the reference pitch in Hertz</p> <code>440.0</code> Source code in <code>staff/pitch.py</code> <pre><code>@dataclass(frozen=True)\nclass Diapason:\n    \"\"\"Tuning reference.\n\n    Args:\n        reference_midi_number: The reference pitch MIDI number\n        reference_hertz: The frequency of the reference pitch in Hertz\n    \"\"\"\n\n    reference_midi_number: int = 69\n    reference_hertz: float = 440.0\n\n    def __post_init__(self):\n        if (self.reference_midi_number &lt; 0) or (self.reference_midi_number &gt; 127):\n            raise ValueError(f\"invalid MIDI note number `{self.reference_midi_number}`\")\n\n        if self.reference_hertz &lt;= 0:\n            raise ValueError(f\"invalid Hertz value `{self.reference_hertz}`\")\n</code></pre>"},{"location":"api/pitch/#frequency","title":"Frequency","text":"<p>Frequency representation.</p> <p>Parameters:</p> Name Type Description Default <code>hertz</code> <code>float</code> <p>The frequency in Hertz (cycles-per-second)</p> required <p>Implements <code>total_ordering</code> against <code>Frequency</code>.</p> <p>Implements the following operations:</p> <pre><code>- `__add__` against `Frequency`\n- `__sub__` against `Frequency`\n- `__mul__` against `int` and `float`\n- `__rmul__` against `int` and `float`\n- `__truediv__` against `int` and `float`\n- `__floor_div__` against `int` and `float`\n- `__round__`\n</code></pre> <p>Implements total ordering.</p> <p>Examples:</p> <p>Converting to a <code>MIDIPitch</code>:</p> <pre><code>&gt;&gt;&gt; Frequency(hertz=440).to_midi()\nMIDIPitch(number=69, bend=MIDIBend(bend=0, bend_range=200))\n</code></pre> <pre><code>&gt;&gt;&gt; Frequency(hertz=450).to_midi()\nMIDIPitch(number=69, bend=MIDIBend(bend=1594, bend_range=200))\n</code></pre> <p>The distance between two <code>Frequency</code> instances (exponential) in <code>Cents</code> (linear):</p> <pre><code>&gt;&gt;&gt; Frequency(880).cents_distance(Frequency(440))\nCents(cents=-1200.0)\n</code></pre> <pre><code>&gt;&gt;&gt; round(Frequency(440).cents_distance(Frequency(660)), 2)\nCents(cents=701.96)\n</code></pre> <p>Adding <code>Cents</code> (linear) to <code>Frequency</code> (exponential):</p> <pre><code>&gt;&gt;&gt; Frequency(40).plus_cents(Cents(2400))\nFrequency(hertz=160.0)\n</code></pre> <pre><code>&gt;&gt;&gt; round(Frequency(40).plus_cents(Cents(2401)), 2)\nFrequency(hertz=160.09)\n</code></pre> <p><code>Frequency</code> arithmetic is simple:</p> <pre><code>&gt;&gt;&gt; Frequency(hertz=440) + Frequency(hertz=220)\nFrequency(hertz=660)\n</code></pre> <pre><code>&gt;&gt;&gt; Frequency(hertz=660) - Frequency(hertz=220)\nFrequency(hertz=440)\n</code></pre> <pre><code>&gt;&gt;&gt; Frequency(hertz=440) * 2\nFrequency(hertz=880)\n</code></pre> <pre><code>&gt;&gt;&gt; Frequency(hertz=440) / 2\nFrequency(hertz=220.0)\n</code></pre> <pre><code>&gt;&gt;&gt; round(Frequency(hertz=261.6255653005986), 2)\nFrequency(hertz=261.63)\n</code></pre> <p>As is comparison:</p> <pre><code>&gt;&gt;&gt; Frequency(220) &gt; Frequency(110)\nTrue\n</code></pre> Source code in <code>staff/pitch.py</code> <pre><code>@total_ordering\n@dataclass(frozen=True)\nclass Frequency:\n    \"\"\"Frequency representation.\n\n    Args:\n        hertz: The frequency in Hertz (cycles-per-second)\n\n    Implements `total_ordering` against `Frequency`.\n\n    Implements the following operations:\n\n        - `__add__` against `Frequency`\n        - `__sub__` against `Frequency`\n        - `__mul__` against `int` and `float`\n        - `__rmul__` against `int` and `float`\n        - `__truediv__` against `int` and `float`\n        - `__floor_div__` against `int` and `float`\n        - `__round__`\n\n    Implements total ordering.\n\n    Examples:\n        Converting to a `MIDIPitch`:\n\n        &gt;&gt;&gt; Frequency(hertz=440).to_midi()\n        MIDIPitch(number=69, bend=MIDIBend(bend=0, bend_range=200))\n\n        &gt;&gt;&gt; Frequency(hertz=450).to_midi()\n        MIDIPitch(number=69, bend=MIDIBend(bend=1594, bend_range=200))\n\n        The distance between two `Frequency` instances (exponential) in `Cents`\n        (linear):\n\n        &gt;&gt;&gt; Frequency(880).cents_distance(Frequency(440))\n        Cents(cents=-1200.0)\n\n        &gt;&gt;&gt; round(Frequency(440).cents_distance(Frequency(660)), 2)\n        Cents(cents=701.96)\n\n        Adding `Cents` (linear) to `Frequency` (exponential):\n\n        &gt;&gt;&gt; Frequency(40).plus_cents(Cents(2400))\n        Frequency(hertz=160.0)\n\n        &gt;&gt;&gt; round(Frequency(40).plus_cents(Cents(2401)), 2)\n        Frequency(hertz=160.09)\n\n        `Frequency` arithmetic is simple:\n\n        &gt;&gt;&gt; Frequency(hertz=440) + Frequency(hertz=220)\n        Frequency(hertz=660)\n\n        &gt;&gt;&gt; Frequency(hertz=660) - Frequency(hertz=220)\n        Frequency(hertz=440)\n\n        &gt;&gt;&gt; Frequency(hertz=440) * 2\n        Frequency(hertz=880)\n\n        &gt;&gt;&gt; Frequency(hertz=440) / 2\n        Frequency(hertz=220.0)\n\n        &gt;&gt;&gt; round(Frequency(hertz=261.6255653005986), 2)\n        Frequency(hertz=261.63)\n\n        As is comparison:\n\n        &gt;&gt;&gt; Frequency(220) &gt; Frequency(110)\n        True\n    \"\"\"\n\n    hertz: float\n\n    def __post_init__(self):\n        if self.hertz &lt;= 0:\n            raise ValueError(f\"hertz must be greater than 0. Got {self.hertz}\")\n\n    def to_midi(\n        self,\n        midi_bend_range: int = 200,\n        diapason: Diapason = Diapason(),\n        octave_divs: int = 12,\n    ) -&gt; MIDIPitch:\n        \"\"\"Frequency to MIDIPitch conversion.\"\"\"\n        midi_float = (\n            octave_divs * log2(self.hertz / diapason.reference_hertz)\n            + diapason.reference_midi_number\n        )\n        try:\n            bend = Cents(100 * divmod(midi_float, int(midi_float))[1]).to_midi_bend(\n                bend_range=midi_bend_range\n            )\n        except ZeroDivisionError:\n            # MIDI note 0\n            bend = Cents(100 * midi_float).to_midi_bend(bend_range=midi_bend_range)\n        return MIDIPitch(\n            number=floor(midi_float),\n            bend=bend,\n            diapason=diapason,\n            octave_divs=octave_divs,\n        )\n\n    def cents_distance(self, other: Frequency) -&gt; Cents:\n        \"\"\"Cents distance between two frequencies.\"\"\"\n        if not isinstance(other, Frequency):\n            raise TypeError(\"other must be an instance of Frequency.\")\n        return Cents((1200 * log2(other.hertz / self.hertz)))\n\n    def plus_cents(self, cents: Cents) -&gt; Frequency:\n        \"\"\"Frequency cents distance away.\"\"\"\n        if not isinstance(cents, Cents):\n            raise TypeError(\"cents must be an instance of Cents.\")\n        return Frequency(hertz=self.hertz * 2 ** (cents.proportion_of_octave))\n\n    def __gt__(self, other: Frequency) -&gt; bool:\n        if not isinstance(other, Frequency):\n            raise TypeError(f\"cannot compare Frequency with type '{type(other)}'\")\n        return self.hertz &gt; other.hertz\n\n    def _operate(\n        self,\n        other: Union[int, float],\n        oper: Callable,\n    ) -&gt; Frequency:\n        return Frequency(hertz=oper(self.hertz, other))\n\n    def __add__(self, other: Frequency) -&gt; Frequency:\n        if not isinstance(other, Frequency):\n            raise TypeError(\n                f\"unsupported operand type(s) for +: 'Frequency' and '{type(other)}'\"\n            )\n        return Frequency(self.hertz + other.hertz)\n\n    def __sub__(self, other: Frequency) -&gt; Frequency:\n        if not isinstance(other, Frequency):\n            raise TypeError(\n                f\"unsupported operand type(s) for -: 'Frequency' and '{type(other)}'\"\n            )\n        return Frequency(self.hertz - other.hertz)\n\n    def __mul__(self, other: Union[int, float]) -&gt; Frequency:\n        return self._operate(other, operator.mul)\n\n    def __rmul__(self, other: Union[int, float]) -&gt; Frequency:\n        return self._operate(other, operator.mul)\n\n    def __truediv__(self, other: Union[int, float]) -&gt; Frequency:\n        return self._operate(other, operator.truediv)\n\n    def __floordiv__(self, other: Union[int, float]) -&gt; Frequency:\n        return self._operate(other, operator.floordiv)\n\n    def __round__(self, ndigits: int) -&gt; Frequency:\n        return Frequency(hertz=round(self.hertz, ndigits))\n</code></pre>"},{"location":"api/pitch/#staff.pitch.Frequency.cents_distance","title":"<code>cents_distance(other)</code>","text":"<p>Cents distance between two frequencies.</p> Source code in <code>staff/pitch.py</code> <pre><code>def cents_distance(self, other: Frequency) -&gt; Cents:\n    \"\"\"Cents distance between two frequencies.\"\"\"\n    if not isinstance(other, Frequency):\n        raise TypeError(\"other must be an instance of Frequency.\")\n    return Cents((1200 * log2(other.hertz / self.hertz)))\n</code></pre>"},{"location":"api/pitch/#staff.pitch.Frequency.plus_cents","title":"<code>plus_cents(cents)</code>","text":"<p>Frequency cents distance away.</p> Source code in <code>staff/pitch.py</code> <pre><code>def plus_cents(self, cents: Cents) -&gt; Frequency:\n    \"\"\"Frequency cents distance away.\"\"\"\n    if not isinstance(cents, Cents):\n        raise TypeError(\"cents must be an instance of Cents.\")\n    return Frequency(hertz=self.hertz * 2 ** (cents.proportion_of_octave))\n</code></pre>"},{"location":"api/pitch/#staff.pitch.Frequency.to_midi","title":"<code>to_midi(midi_bend_range=200, diapason=Diapason(), octave_divs=12)</code>","text":"<p>Frequency to MIDIPitch conversion.</p> Source code in <code>staff/pitch.py</code> <pre><code>def to_midi(\n    self,\n    midi_bend_range: int = 200,\n    diapason: Diapason = Diapason(),\n    octave_divs: int = 12,\n) -&gt; MIDIPitch:\n    \"\"\"Frequency to MIDIPitch conversion.\"\"\"\n    midi_float = (\n        octave_divs * log2(self.hertz / diapason.reference_hertz)\n        + diapason.reference_midi_number\n    )\n    try:\n        bend = Cents(100 * divmod(midi_float, int(midi_float))[1]).to_midi_bend(\n            bend_range=midi_bend_range\n        )\n    except ZeroDivisionError:\n        # MIDI note 0\n        bend = Cents(100 * midi_float).to_midi_bend(bend_range=midi_bend_range)\n    return MIDIPitch(\n        number=floor(midi_float),\n        bend=bend,\n        diapason=diapason,\n        octave_divs=octave_divs,\n    )\n</code></pre>"},{"location":"api/pitch/#cents","title":"Cents","text":"<p>Cents representation.</p> <p>Parameters:</p> Name Type Description Default <code>cents</code> <code>float</code> <p>The cents value. There are 1200 cents per octave.</p> required <p>Implements the following operations:</p> <pre><code>- `__add__` against `Cents`\n- `__sub__` against `Cents`\n- `__mul__` against `int` and `float`\n- `__rmul__` against `int` and `float`\n- `__truediv__` against `int` and `float` (though the result is rounded\n    to the **closest** int)\n- `__floor_div__` against `int` and `float`\n</code></pre> <p>Implements total ordering.</p> <p>Examples:</p> <p><code>Cents</code> as a proportion of the octave:</p> <pre><code>&gt;&gt;&gt; Cents(600).proportion_of_octave\n0.5\n</code></pre> <p><code>Cents</code> can be converted to <code>MIDIBend</code>:</p> <pre><code>&gt;&gt;&gt; Cents(1.96).to_midi_bend()\nMIDIBend(bend=80, bend_range=200)\n</code></pre> <pre><code>&gt;&gt;&gt; Cents(-15.64).to_midi_bend()\nMIDIBend(bend=-641, bend_range=200)\n</code></pre> <p><code>Cents</code> arithmetic is simple:</p> <pre><code>&gt;&gt;&gt; Cents(100) + Cents(500)\nCents(cents=600)\n</code></pre> <pre><code>&gt;&gt;&gt; Cents(600) - Cents(100)\nCents(cents=500)\n</code></pre> <pre><code>&gt;&gt;&gt; Cents(600) * 2\nCents(cents=1200)\n</code></pre> <pre><code>&gt;&gt;&gt; Cents(1200) / 2\nCents(cents=600)\n</code></pre> <pre><code>&gt;&gt;&gt; round(Cents(1.96), 0)\nCents(cents=2.0)\n</code></pre> <p>As is comparison:</p> <pre><code>&gt;&gt;&gt; Cents(600) &gt; Cents(100)\nTrue\n</code></pre> Source code in <code>staff/pitch.py</code> <pre><code>@total_ordering\n@dataclass(frozen=True)\nclass Cents:\n    \"\"\"Cents representation.\n\n    Args:\n        cents: The cents value. There are 1200 cents per octave.\n\n    Implements the following operations:\n\n        - `__add__` against `Cents`\n        - `__sub__` against `Cents`\n        - `__mul__` against `int` and `float`\n        - `__rmul__` against `int` and `float`\n        - `__truediv__` against `int` and `float` (though the result is rounded\n            to the **closest** int)\n        - `__floor_div__` against `int` and `float`\n\n    Implements total ordering.\n\n    Examples:\n        `Cents` as a proportion of the octave:\n\n        &gt;&gt;&gt; Cents(600).proportion_of_octave\n        0.5\n\n        `Cents` can be converted to `MIDIBend`:\n\n        &gt;&gt;&gt; Cents(1.96).to_midi_bend()\n        MIDIBend(bend=80, bend_range=200)\n\n        &gt;&gt;&gt; Cents(-15.64).to_midi_bend()\n        MIDIBend(bend=-641, bend_range=200)\n\n        `Cents` arithmetic is simple:\n\n        &gt;&gt;&gt; Cents(100) + Cents(500)\n        Cents(cents=600)\n\n        &gt;&gt;&gt; Cents(600) - Cents(100)\n        Cents(cents=500)\n\n        &gt;&gt;&gt; Cents(600) * 2\n        Cents(cents=1200)\n\n        &gt;&gt;&gt; Cents(1200) / 2\n        Cents(cents=600)\n\n        &gt;&gt;&gt; round(Cents(1.96), 0)\n        Cents(cents=2.0)\n\n        As is comparison:\n        &gt;&gt;&gt; Cents(600) &gt; Cents(100)\n        True\n    \"\"\"\n\n    cents: float\n\n    @property\n    def proportion_of_octave(self) -&gt; float:\n        \"\"\"Ratio of these cents against a standard 1200 cent octave.\n\n        Returns:\n            The proportion (ratio) of these cents against the 1200 cent octave\n        \"\"\"\n        return self.cents / 1200.0\n\n    def to_midi_bend(self, bend_range: int = 200) -&gt; MIDIBend:\n        \"\"\"MIDI bend value required to achieve these cents.\n\n        Args:\n            bend_range: The set pitch-bend range\n\n        Returns:\n            The MIDIBend equivalent of these cents\n        \"\"\"\n        return MIDIBend(\n            bend=round((8192 / bend_range) * self.cents),\n            bend_range=bend_range,\n        )\n\n    def __gt__(self, other: Cents) -&gt; bool:\n        if not isinstance(other, Cents):\n            raise TypeError(f\"cannot compare Cents with type '{type(other)}'\")\n        return self.cents &gt; other.cents\n\n    def _operate(\n        self,\n        other: Union[int, float],\n        oper: Callable,\n    ) -&gt; Cents:\n        if not isinstance(other, (int, float)):\n            raise TypeError(\n                f\"unsupported operand type(s) for {oper.__name__}: \"\n                f\"'Cents' and '{type(other)}'\"\n            )\n        return Cents(cents=round(oper(self.cents, other)))\n\n    def __add__(self, other: Cents) -&gt; Cents:\n        if not isinstance(other, Cents):\n            raise TypeError(\n                f\"unsupported operand type(s) for +: 'Cents' and '{type(other)}'\"\n            )\n        return Cents(self.cents + other.cents)\n\n    def __sub__(self, other: Cents) -&gt; Cents:\n        if not isinstance(other, Cents):\n            raise TypeError(\n                f\"unsupported operand type(s) for -: 'Cents' and '{type(other)}'\"\n            )\n        return Cents(self.cents - other.cents)\n\n    def __mul__(self, other: Union[int, float]) -&gt; Cents:\n        return self._operate(other, operator.mul)\n\n    def __rmul__(self, other: Union[int, float]) -&gt; Cents:\n        return self._operate(other, operator.mul)\n\n    def __truediv__(self, other: Union[int, float]) -&gt; Cents:\n        return self._operate(other, operator.truediv)\n\n    def __floordiv__(self, other: Union[int, float]) -&gt; Cents:\n        return self._operate(other, operator.floordiv)\n\n    def __round__(self, ndigits: Optional[int] = None) -&gt; Cents:\n        return Cents(cents=round(self.cents, ndigits))\n</code></pre>"},{"location":"api/pitch/#staff.pitch.Cents.proportion_of_octave","title":"<code>proportion_of_octave: float</code>  <code>property</code>","text":"<p>Ratio of these cents against a standard 1200 cent octave.</p> <p>Returns:</p> Type Description <code>float</code> <p>The proportion (ratio) of these cents against the 1200 cent octave</p>"},{"location":"api/pitch/#staff.pitch.Cents.to_midi_bend","title":"<code>to_midi_bend(bend_range=200)</code>","text":"<p>MIDI bend value required to achieve these cents.</p> <p>Parameters:</p> Name Type Description Default <code>bend_range</code> <code>int</code> <p>The set pitch-bend range</p> <code>200</code> <p>Returns:</p> Type Description <code>MIDIBend</code> <p>The MIDIBend equivalent of these cents</p> Source code in <code>staff/pitch.py</code> <pre><code>def to_midi_bend(self, bend_range: int = 200) -&gt; MIDIBend:\n    \"\"\"MIDI bend value required to achieve these cents.\n\n    Args:\n        bend_range: The set pitch-bend range\n\n    Returns:\n        The MIDIBend equivalent of these cents\n    \"\"\"\n    return MIDIBend(\n        bend=round((8192 / bend_range) * self.cents),\n        bend_range=bend_range,\n    )\n</code></pre>"},{"location":"api/pitch/#midipitch","title":"MIDIPitch","text":"<p>MIDI pitch representation which includes pitch-bend.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>MIDI note number.</p> required <code>bend</code> <code>MIDIBend</code> <p>MIDI pitch-wheel bend.</p> <code>MIDIBend(bend=0, bend_range=200)</code> <code>diapason</code> <code>Diapason</code> <p>Tuning reference.</p> <code>Diapason()</code> <code>octave_divs</code> <code>int</code> <p>Equal divisions of the octave. Typically 12.</p> <code>field(default=12, compare=False)</code> <p>Implements total ordering.</p> <p>Examples:</p> <p><code>MIDIPitches</code> can be initialized using a string:</p> <pre><code>&gt;&gt;&gt; MIDIPitch.from_string(\"c4\")\nMIDIPitch(number=60, bend=MIDIBend(bend=0, bend_range=200))\n</code></pre> <pre><code>&gt;&gt;&gt; MIDIPitch.from_string(\"c#4\")\nMIDIPitch(number=61, bend=MIDIBend(bend=0, bend_range=200))\n</code></pre> <pre><code>&gt;&gt;&gt; MIDIPitch.from_string(\"db4\")\nMIDIPitch(number=61, bend=MIDIBend(bend=0, bend_range=200))\n</code></pre> <p>or a number:</p> <pre><code>&gt;&gt;&gt; MIDIPitch(60)\nMIDIPitch(number=60, bend=MIDIBend(bend=0, bend_range=200))\n</code></pre> <p>They can be converted to <code>Frequency</code>:</p> <pre><code>&gt;&gt;&gt; round(MIDIPitch(60).frequency, 2)\nFrequency(hertz=261.63)\n</code></pre> <p>A <code>Diapason</code> can be used to set tuning:</p> <pre><code>&gt;&gt;&gt; diapason = Diapason(reference_midi_number=69, reference_hertz=438)\n&gt;&gt;&gt; pitch = MIDIPitch(60, diapason=diapason)\n&gt;&gt;&gt; round(pitch.frequency, 2)\nFrequency(hertz=260.44)\n</code></pre> <p>Octave divisions other than 12 can be used, changing the MIDI note key mapping:</p> <pre><code>&gt;&gt;&gt; round(MIDIPitch(60, octave_divs=24).frequency, 2)\nFrequency(hertz=339.29)\n</code></pre> <p>Given a pitch that isn't twelve-tone equal-temperament, a <code>MIDIBend</code> will be applied (note that <code>Frequency.to_midi</code> returns a <code>MIDIPitch</code>):</p> <pre><code>&gt;&gt;&gt; Frequency(100).to_midi().bend\nMIDIBend(bend=1433, bend_range=200)\n</code></pre> <p>They can be compared:</p> <pre><code>&gt;&gt;&gt; MIDIPitch.from_string(\"c#4\") == MIDIPitch.from_string(\"db4\")\nTrue\n</code></pre> Source code in <code>staff/pitch.py</code> <pre><code>@total_ordering\n@dataclass(frozen=True, repr=False)\nclass MIDIPitch:\n    \"\"\"MIDI pitch representation which includes pitch-bend.\n\n    Args:\n        number: MIDI note number.\n        bend: MIDI pitch-wheel bend.\n        diapason: Tuning reference.\n        octave_divs: Equal divisions of the octave. Typically 12.\n\n    Implements total ordering.\n\n    Examples:\n        `MIDIPitches` can be initialized using a string:\n\n        &gt;&gt;&gt; MIDIPitch.from_string(\"c4\")\n        MIDIPitch(number=60, bend=MIDIBend(bend=0, bend_range=200))\n\n        &gt;&gt;&gt; MIDIPitch.from_string(\"c#4\")\n        MIDIPitch(number=61, bend=MIDIBend(bend=0, bend_range=200))\n\n        &gt;&gt;&gt; MIDIPitch.from_string(\"db4\")\n        MIDIPitch(number=61, bend=MIDIBend(bend=0, bend_range=200))\n\n        or a number:\n\n        &gt;&gt;&gt; MIDIPitch(60)\n        MIDIPitch(number=60, bend=MIDIBend(bend=0, bend_range=200))\n\n        They can be converted to `Frequency`:\n\n        &gt;&gt;&gt; round(MIDIPitch(60).frequency, 2)\n        Frequency(hertz=261.63)\n\n        A `Diapason` can be used to set tuning:\n\n        &gt;&gt;&gt; diapason = Diapason(reference_midi_number=69, reference_hertz=438)\n        &gt;&gt;&gt; pitch = MIDIPitch(60, diapason=diapason)\n        &gt;&gt;&gt; round(pitch.frequency, 2)\n        Frequency(hertz=260.44)\n\n        Octave divisions other than 12 can be used, changing the MIDI note key\n        mapping:\n\n        &gt;&gt;&gt; round(MIDIPitch(60, octave_divs=24).frequency, 2)\n        Frequency(hertz=339.29)\n\n        Given a pitch that isn't twelve-tone equal-temperament, a `MIDIBend`\n        will be applied (note that `Frequency.to_midi` returns a `MIDIPitch`):\n\n        &gt;&gt;&gt; Frequency(100).to_midi().bend\n        MIDIBend(bend=1433, bend_range=200)\n\n        They can be compared:\n\n        &gt;&gt;&gt; MIDIPitch.from_string(\"c#4\") == MIDIPitch.from_string(\"db4\")\n        True\n    \"\"\"\n\n    number: int\n    bend: MIDIBend = MIDIBend(bend=0, bend_range=200)\n    diapason: Diapason = Diapason()\n    octave_divs: int = field(default=12, compare=False)\n\n    def __post_init__(self):\n        if (self.number &lt; 0) or (self.number &gt; 127):\n            raise ValueError(f\"number must be between 0 and 127. Got {self.number}\")\n\n    def __repr__(self):\n        return f\"MIDIPitch(number={self.number}, bend={self.bend})\"\n\n    def __hash__(self) -&gt; int:\n        return hash(self.number_precise)\n\n    @property\n    def number_precise(self) -&gt; float:\n        \"\"\"The MIDI number with the bend as the fractional part of a float.\n\n        Returns:\n            The precise MIDI number including the bend.\n\n        Examples:\n            &gt;&gt;&gt; MIDIPitch(60, bend=MIDIBend(100, bend_range=200)).number_precise\n            60.5\n        \"\"\"\n        return self.number + (self.bend.bend / self.bend.bend_range)\n\n    @property\n    def frequency(self) -&gt; Frequency:\n        \"\"\"Convert MIDIPitch to Frequency.\n\n        Returns:\n            The MIDIPitch frequency\n        \"\"\"\n        fhz = Frequency(\n            2\n            ** ((self.number - self.diapason.reference_midi_number) / self.octave_divs)\n            * self.diapason.reference_hertz\n        )\n        if self.bend == MIDIBend(bend=0):\n            return fhz\n        cents = self.bend.cents\n        return fhz.plus_cents(cents=cents)\n\n    @property\n    def pitch_class(self) -&gt; int:\n        \"\"\"The approximate pitch class of the pitch.\n\n        Note:\n            This is more utility than function. It uses the integer MIDI number\n            not the precise number that includes the pitch bend.\n\n        Returns:\n            The pitch class of the pitch.\n        \"\"\"\n        return self.number % self.octave_divs\n\n    @property\n    def pitch_class_precise(self) -&gt; MIDIPitch:\n        \"\"\"The lowest octave equivalent of the precise pitch.\n\n        Note:\n            This is recommended for microtonal pitches.\n\n        Returns:\n            The `MIDIPitch` which is the lowest octave equivalent.\n        \"\"\"\n        lower_bound = MIDIPitch(0).frequency.hertz\n        frequency = self.frequency.hertz\n        candidate = frequency / 2.0\n        if candidate &lt; lower_bound:\n            return Frequency(hertz=frequency).to_midi(\n                midi_bend_range=self.bend.bend_range,\n                diapason=self.diapason,\n                octave_divs=self.octave_divs,\n            )\n        while candidate &gt;= lower_bound:\n            frequency = candidate\n            candidate = frequency / 2.0\n        return Frequency(hertz=frequency).to_midi(\n            midi_bend_range=self.bend.bend_range,\n            diapason=self.diapason,\n            octave_divs=self.octave_divs,\n        )\n\n    @classmethod\n    def from_string(cls, pitch: str, c4_number: int = 60) -&gt; MIDIPitch:\n        \"\"\"Create a MIDIPitch from a string representations.\n\n        Pitch strings are written as a combination of the pitch note class letter,\n        a maximum of one accidental, and an integer representing the octave.\n        Sharps are represented by the '#' symbols and flats by 'b'.\n\n        Args:\n            pitch: The pitch in string representation.\n            c4_number: The MIDI number representing C4.\n\n        Raises:\n            ValueError: if an invalid pitch string is given.\n        \"\"\"\n        if not isinstance(pitch, str):\n            raise TypeError(\"pitch must be expressed as a 'str'\")\n        if not isinstance(c4_number, int):\n            raise TypeError(\"c4_number must be expressed as a 'int'\")\n\n        pitches = [\n            [\"b#\", \"c\"],\n            [\"c#\", \"db\"],\n            [\"d\"],\n            [\"d#\", \"eb\"],\n            [\"e\", \"fb\"],\n            [\"f\", \"e#\"],\n            [\"f#\", \"gb\"],\n            [\"g\"],\n            [\"g#\", \"ab\"],\n            [\"a\"],\n            [\"a#\", \"bb\"],\n            [\"b\", \"cb\"],\n        ]\n        pitch = pitch.strip().lower()\n        idx = 1\n        while pitch[-idx].isnumeric():\n            idx += 1\n        idx -= 1\n        if pitch[-(idx + 1)] == \"-\":\n            idx += 1\n        octave = int(pitch[-idx:])\n        pitch_class = pitch[:-idx]\n        found = False\n        pc_number = 0\n        for idx, enharmonics in enumerate(pitches):\n            if pitch_class in enharmonics:\n                pc_number = idx\n                found = True\n                break\n        if not found:\n            raise ValueError(f\"invalid pitch string : {pitch}\")\n        if pitch_class == \"b#\":\n            octave += 1\n        elif pitch_class == \"cb\":\n            octave -= 1\n        return MIDIPitch((c4_number + pc_number) + (octave - 4) * 12)\n\n    def octave_up(self) -&gt; MIDIPitch:\n        return Frequency(self.frequency.hertz * 2).to_midi(\n            midi_bend_range=self.bend.bend_range,\n            diapason=self.diapason,\n            octave_divs=self.octave_divs,\n        )\n\n    def octave_down(self) -&gt; MIDIPitch:\n        return Frequency(self.frequency.hertz / 2).to_midi(\n            midi_bend_range=self.bend.bend_range,\n            diapason=self.diapason,\n            octave_divs=self.octave_divs,\n        )\n\n    def __gt__(self, other: MIDIPitch) -&gt; bool:\n        if not isinstance(other, MIDIPitch):\n            raise TypeError(f\"cannot compare MIDIPitch with type '{type(other)}'\")\n        return self.frequency &gt; other.frequency\n</code></pre>"},{"location":"api/pitch/#staff.pitch.MIDIPitch.frequency","title":"<code>frequency: Frequency</code>  <code>property</code>","text":"<p>Convert MIDIPitch to Frequency.</p> <p>Returns:</p> Type Description <code>Frequency</code> <p>The MIDIPitch frequency</p>"},{"location":"api/pitch/#staff.pitch.MIDIPitch.number_precise","title":"<code>number_precise: float</code>  <code>property</code>","text":"<p>The MIDI number with the bend as the fractional part of a float.</p> <p>Returns:</p> Type Description <code>float</code> <p>The precise MIDI number including the bend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; MIDIPitch(60, bend=MIDIBend(100, bend_range=200)).number_precise\n60.5\n</code></pre>"},{"location":"api/pitch/#staff.pitch.MIDIPitch.pitch_class","title":"<code>pitch_class: int</code>  <code>property</code>","text":"<p>The approximate pitch class of the pitch.</p> Note <p>This is more utility than function. It uses the integer MIDI number not the precise number that includes the pitch bend.</p> <p>Returns:</p> Type Description <code>int</code> <p>The pitch class of the pitch.</p>"},{"location":"api/pitch/#staff.pitch.MIDIPitch.pitch_class_precise","title":"<code>pitch_class_precise: MIDIPitch</code>  <code>property</code>","text":"<p>The lowest octave equivalent of the precise pitch.</p> Note <p>This is recommended for microtonal pitches.</p> <p>Returns:</p> Type Description <code>MIDIPitch</code> <p>The <code>MIDIPitch</code> which is the lowest octave equivalent.</p>"},{"location":"api/pitch/#staff.pitch.MIDIPitch.from_string","title":"<code>from_string(pitch, c4_number=60)</code>  <code>classmethod</code>","text":"<p>Create a MIDIPitch from a string representations.</p> <p>Pitch strings are written as a combination of the pitch note class letter, a maximum of one accidental, and an integer representing the octave. Sharps are represented by the '#' symbols and flats by 'b'.</p> <p>Parameters:</p> Name Type Description Default <code>pitch</code> <code>str</code> <p>The pitch in string representation.</p> required <code>c4_number</code> <code>int</code> <p>The MIDI number representing C4.</p> <code>60</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if an invalid pitch string is given.</p> Source code in <code>staff/pitch.py</code> <pre><code>@classmethod\ndef from_string(cls, pitch: str, c4_number: int = 60) -&gt; MIDIPitch:\n    \"\"\"Create a MIDIPitch from a string representations.\n\n    Pitch strings are written as a combination of the pitch note class letter,\n    a maximum of one accidental, and an integer representing the octave.\n    Sharps are represented by the '#' symbols and flats by 'b'.\n\n    Args:\n        pitch: The pitch in string representation.\n        c4_number: The MIDI number representing C4.\n\n    Raises:\n        ValueError: if an invalid pitch string is given.\n    \"\"\"\n    if not isinstance(pitch, str):\n        raise TypeError(\"pitch must be expressed as a 'str'\")\n    if not isinstance(c4_number, int):\n        raise TypeError(\"c4_number must be expressed as a 'int'\")\n\n    pitches = [\n        [\"b#\", \"c\"],\n        [\"c#\", \"db\"],\n        [\"d\"],\n        [\"d#\", \"eb\"],\n        [\"e\", \"fb\"],\n        [\"f\", \"e#\"],\n        [\"f#\", \"gb\"],\n        [\"g\"],\n        [\"g#\", \"ab\"],\n        [\"a\"],\n        [\"a#\", \"bb\"],\n        [\"b\", \"cb\"],\n    ]\n    pitch = pitch.strip().lower()\n    idx = 1\n    while pitch[-idx].isnumeric():\n        idx += 1\n    idx -= 1\n    if pitch[-(idx + 1)] == \"-\":\n        idx += 1\n    octave = int(pitch[-idx:])\n    pitch_class = pitch[:-idx]\n    found = False\n    pc_number = 0\n    for idx, enharmonics in enumerate(pitches):\n        if pitch_class in enharmonics:\n            pc_number = idx\n            found = True\n            break\n    if not found:\n        raise ValueError(f\"invalid pitch string : {pitch}\")\n    if pitch_class == \"b#\":\n        octave += 1\n    elif pitch_class == \"cb\":\n        octave -= 1\n    return MIDIPitch((c4_number + pc_number) + (octave - 4) * 12)\n</code></pre>"},{"location":"api/pitch/#midibend","title":"MIDIBend","text":"<p>MIDI bend value with bend wheel range.</p> <p>Parameters:</p> Name Type Description Default <code>bend</code> <code>int</code> <p>MIDI pitch bend value (in range -8192, 8192)</p> <code>0</code> <code>bend_range</code> <code>int</code> <p>MIDI bend wheel range in cents. Typically 200 (2 semitones), but with some MPE instruments and controllers the bend range is set to 2400 (24 semitones).</p> <code>200</code> Source code in <code>staff/pitch.py</code> <pre><code>@dataclass(frozen=True)\nclass MIDIBend:\n    \"\"\"MIDI bend value with bend wheel range.\n\n    Args:\n        bend: MIDI pitch bend value (in range -8192, 8192)\n        bend_range: MIDI bend wheel range in cents. Typically 200 (2 semitones),\n            but with some MPE instruments and controllers the bend range is set\n            to 2400 (24 semitones).\n    \"\"\"\n\n    bend: int = 0\n    bend_range: int = 200\n\n    def __post_init__(self):\n        if (self.bend &lt; -8192) or (self.bend &gt; 8192):\n            raise ValueError(f\"bend must be between -8192 and 8192. Got {self.bend}\")\n\n        if self.bend_range &lt;= 0:\n            raise ValueError(\n                f\"bend_range must be greater than 0. Got {self.bend_range}\"\n            )\n\n    @property\n    def cents(self) -&gt; Cents:\n        \"\"\"Get this MIDI bend value as cents.\n\n        Returns:\n            The MIDIBend as cents\n        \"\"\"\n        return Cents((self.bend / 8192) * self.bend_range)\n</code></pre>"},{"location":"api/pitch/#staff.pitch.MIDIBend.cents","title":"<code>cents: Cents</code>  <code>property</code>","text":"<p>Get this MIDI bend value as cents.</p> <p>Returns:</p> Type Description <code>Cents</code> <p>The MIDIBend as cents</p>"},{"location":"api/patterns/duration/","title":"duration","text":""},{"location":"api/patterns/duration/#durationpattern","title":"DurationPattern","text":"<p>             Bases: <code>_BasePattern</code></p> <p>Musical duration pattern.</p> <p>Implements the following operations:</p> <pre><code>- `__hash__`\n- `__len__`\n- `__getitem__`\n- `__mul__` against `float`\n- `__truediv__` against `float`\n</code></pre> Note <p>All operations return a copy, <code>DurationPattern</code>s are immutable.</p> Source code in <code>staff/patterns/duration.py</code> <pre><code>class DurationPattern(_BasePattern):\n    \"\"\"Musical duration pattern.\n\n    Implements the following operations:\n\n        - `__hash__`\n        - `__len__`\n        - `__getitem__`\n        - `__mul__` against `float`\n        - `__truediv__` against `float`\n\n    Note:\n        All operations return a copy, `DurationPattern`s are immutable.\n    \"\"\"\n\n    def __init__(self, pattern: List[Duration]):\n        \"\"\"Initialises a DurationPattern\n\n        Args:\n            pattern: The initial pattern\n\n        Raises:\n            TypeError: If anything but a Duration is included in the initial list\n        \"\"\"\n        for dur in pattern:\n            if not isinstance(dur, Duration):\n                raise TypeError(\"DurationPattern can only contain Duration objects\")\n        self._pat = pattern\n\n    def append(self, value: Duration) -&gt; DurationPattern:\n        \"\"\"Append a duration to the pattern\n\n        Args:\n            value: A duration to append\n\n        Raises:\n            TypeError: If anything but a Duration is passed in\n\n        Returns:\n            A new `DurationPattern` (they are immutable)\n        \"\"\"\n        if not isinstance(value, Duration):\n            raise TypeError(\"DurationPattern can only contain Duration objects\")\n        return DurationPattern([value] + self._pat)\n\n    def prepend(self, value: Duration) -&gt; DurationPattern:\n        \"\"\"Insert a duration value at the start of the pattern.\n\n        Args:\n            value: A duration to prepend\n\n        Raises:\n            TypeError: If anything but a Duration is passed in\n\n        Returns:\n            A new `DurationPattern` (they are immutable)\n        \"\"\"\n        if not isinstance(value, Duration):\n            raise TypeError(\"DurationPattern can only contain Duration objects\")\n        return DurationPattern(self._pat + [value])\n\n    def milliseconds(self, tempo: Tempo) -&gt; float:\n        \"\"\"Total millisecond duration of the pattern.\n\n        Args:\n            tempo: The tempo used to measure time\n\n        Returns:\n            Total milliseconds\n        \"\"\"\n        return sum((dur.milliseconds(tempo) for dur in self._pat))\n\n    def retrograde(self) -&gt; DurationPattern:\n        \"\"\"The pattern's retrograde.\n\n        Returns:\n            The pattern's retrograde as a new `DurationPattern` (they are immutable)\n        \"\"\"\n        return DurationPattern(pattern=self._pat[::-1])\n\n    def rotate(self, factor: int) -&gt; DurationPattern:\n        \"\"\"Rotates the pattern.\n\n        Args:\n            factor: The rotation factor (how many durations to rotate). Can be\n                negative to rotate left.\n\n        Raises:\n            TypeError: If anything but an `int` is passed for factor\n\n        Returns:\n            A new and rotated `DurationPattern` (they are immutable)\n        \"\"\"\n        if not isinstance(factor, int):\n            raise TypeError(\"can only rotate by an 'int' factor\")\n        return DurationPattern(pattern=self._pat[factor:] + self._pat[:factor])\n\n    def prolate(self, factor: Union[int, float]) -&gt; DurationPattern:\n        \"\"\"Stretches or contracts the pattern.\n\n        Args;\n            factor: Augment with factor &gt; 1, diminish with 0 &lt; factor &lt; 1\n\n        Returns:\n            The prolated pattern (as a copy)\n        \"\"\"\n        return self * factor\n\n    def permutations(self) -&gt; List[DurationPattern]:\n        return [DurationPattern(list(pat)) for pat in it.permutations(self._pat)]\n\n    def __repr__(self):\n        _repr = f\"{self.__class__.__name__}([\"\n        for dur in self._pat:\n            _repr += str(dur.denominator)\n            _repr += \".\" * dur.dots\n            _repr += \"r\" if dur.is_rest else \"\"\n            _repr += \", \"\n        return _repr[:-2] + \"])\"\n\n    def __mul__(self, other: float) -&gt; DurationPattern:\n        return DurationPattern([dur * other for dur in self._pat])\n\n    def __truediv__(self, other: float) -&gt; DurationPattern:\n        return DurationPattern([dur / other for dur in self._pat])\n</code></pre>"},{"location":"api/patterns/duration/#staff.patterns.duration.DurationPattern.__init__","title":"<code>__init__(pattern)</code>","text":"<p>Initialises a DurationPattern</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>List[Duration]</code> <p>The initial pattern</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If anything but a Duration is included in the initial list</p> Source code in <code>staff/patterns/duration.py</code> <pre><code>def __init__(self, pattern: List[Duration]):\n    \"\"\"Initialises a DurationPattern\n\n    Args:\n        pattern: The initial pattern\n\n    Raises:\n        TypeError: If anything but a Duration is included in the initial list\n    \"\"\"\n    for dur in pattern:\n        if not isinstance(dur, Duration):\n            raise TypeError(\"DurationPattern can only contain Duration objects\")\n    self._pat = pattern\n</code></pre>"},{"location":"api/patterns/duration/#staff.patterns.duration.DurationPattern.append","title":"<code>append(value)</code>","text":"<p>Append a duration to the pattern</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Duration</code> <p>A duration to append</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If anything but a Duration is passed in</p> <p>Returns:</p> Type Description <code>DurationPattern</code> <p>A new <code>DurationPattern</code> (they are immutable)</p> Source code in <code>staff/patterns/duration.py</code> <pre><code>def append(self, value: Duration) -&gt; DurationPattern:\n    \"\"\"Append a duration to the pattern\n\n    Args:\n        value: A duration to append\n\n    Raises:\n        TypeError: If anything but a Duration is passed in\n\n    Returns:\n        A new `DurationPattern` (they are immutable)\n    \"\"\"\n    if not isinstance(value, Duration):\n        raise TypeError(\"DurationPattern can only contain Duration objects\")\n    return DurationPattern([value] + self._pat)\n</code></pre>"},{"location":"api/patterns/duration/#staff.patterns.duration.DurationPattern.milliseconds","title":"<code>milliseconds(tempo)</code>","text":"<p>Total millisecond duration of the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>tempo</code> <code>Tempo</code> <p>The tempo used to measure time</p> required <p>Returns:</p> Type Description <code>float</code> <p>Total milliseconds</p> Source code in <code>staff/patterns/duration.py</code> <pre><code>def milliseconds(self, tempo: Tempo) -&gt; float:\n    \"\"\"Total millisecond duration of the pattern.\n\n    Args:\n        tempo: The tempo used to measure time\n\n    Returns:\n        Total milliseconds\n    \"\"\"\n    return sum((dur.milliseconds(tempo) for dur in self._pat))\n</code></pre>"},{"location":"api/patterns/duration/#staff.patterns.duration.DurationPattern.prepend","title":"<code>prepend(value)</code>","text":"<p>Insert a duration value at the start of the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Duration</code> <p>A duration to prepend</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If anything but a Duration is passed in</p> <p>Returns:</p> Type Description <code>DurationPattern</code> <p>A new <code>DurationPattern</code> (they are immutable)</p> Source code in <code>staff/patterns/duration.py</code> <pre><code>def prepend(self, value: Duration) -&gt; DurationPattern:\n    \"\"\"Insert a duration value at the start of the pattern.\n\n    Args:\n        value: A duration to prepend\n\n    Raises:\n        TypeError: If anything but a Duration is passed in\n\n    Returns:\n        A new `DurationPattern` (they are immutable)\n    \"\"\"\n    if not isinstance(value, Duration):\n        raise TypeError(\"DurationPattern can only contain Duration objects\")\n    return DurationPattern(self._pat + [value])\n</code></pre>"},{"location":"api/patterns/duration/#staff.patterns.duration.DurationPattern.prolate","title":"<code>prolate(factor)</code>","text":"<p>Stretches or contracts the pattern.</p> <p>Args;     factor: Augment with factor &gt; 1, diminish with 0 &lt; factor &lt; 1</p> <p>Returns:</p> Type Description <code>DurationPattern</code> <p>The prolated pattern (as a copy)</p> Source code in <code>staff/patterns/duration.py</code> <pre><code>def prolate(self, factor: Union[int, float]) -&gt; DurationPattern:\n    \"\"\"Stretches or contracts the pattern.\n\n    Args;\n        factor: Augment with factor &gt; 1, diminish with 0 &lt; factor &lt; 1\n\n    Returns:\n        The prolated pattern (as a copy)\n    \"\"\"\n    return self * factor\n</code></pre>"},{"location":"api/patterns/duration/#staff.patterns.duration.DurationPattern.retrograde","title":"<code>retrograde()</code>","text":"<p>The pattern's retrograde.</p> <p>Returns:</p> Type Description <code>DurationPattern</code> <p>The pattern's retrograde as a new <code>DurationPattern</code> (they are immutable)</p> Source code in <code>staff/patterns/duration.py</code> <pre><code>def retrograde(self) -&gt; DurationPattern:\n    \"\"\"The pattern's retrograde.\n\n    Returns:\n        The pattern's retrograde as a new `DurationPattern` (they are immutable)\n    \"\"\"\n    return DurationPattern(pattern=self._pat[::-1])\n</code></pre>"},{"location":"api/patterns/duration/#staff.patterns.duration.DurationPattern.rotate","title":"<code>rotate(factor)</code>","text":"<p>Rotates the pattern.</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>int</code> <p>The rotation factor (how many durations to rotate). Can be negative to rotate left.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If anything but an <code>int</code> is passed for factor</p> <p>Returns:</p> Type Description <code>DurationPattern</code> <p>A new and rotated <code>DurationPattern</code> (they are immutable)</p> Source code in <code>staff/patterns/duration.py</code> <pre><code>def rotate(self, factor: int) -&gt; DurationPattern:\n    \"\"\"Rotates the pattern.\n\n    Args:\n        factor: The rotation factor (how many durations to rotate). Can be\n            negative to rotate left.\n\n    Raises:\n        TypeError: If anything but an `int` is passed for factor\n\n    Returns:\n        A new and rotated `DurationPattern` (they are immutable)\n    \"\"\"\n    if not isinstance(factor, int):\n        raise TypeError(\"can only rotate by an 'int' factor\")\n    return DurationPattern(pattern=self._pat[factor:] + self._pat[:factor])\n</code></pre>"}]}